<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Evaluation / 判定可視化</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.plot.ly/plotly-2.25.2.min.js"></script>

<style>
body {
  font-family: sans-serif;
  margin: 20px;
  text-align: center;
}

#plot {
  width: 95%;
  max-width: 1100px;
  height: 650px;
  margin: 20px auto;
}

button {
  margin: 4px;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
}
</style>
</head>

<body>

<h1>自動判定・GT 評価 / 判定式可視化</h1>

<div>
  <button id="btnScatter">判定式（diff × xyMean）</button>
  <button id="btnHist">diff 分布</button>
  <button id="btnConfusion">自動判定 vs GT</button>
  <button id="btnDecision">判定式決定説明</button>
  <button id="btnMetrics">評価指標（表）</button>
  <button id="btnDownloadCsv">CSVをダウンロード</button>
  <button id="btnDownloadAll">イベント全波形データCSV</button>
  <button id="btnScore">スコア可視化</button>
</div>

<div id="plot"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

/* Firebase */
const app = initializeApp({
  apiKey: "AIzaSyAb9Zt2Hw_o-wXfXby6vlBDdcWZ6xZUJpo",
  projectId: "bike-barrier-detector-1e128"
});
const db = getFirestore(app);

/* 定義 */
const KEYS = ["step","curve","hill","flat"];
const LABEL = { step:"段差", curve:"カーブ", hill:"坂", flat:"平地" };
const COLOR = { step:"red", curve:"blue", hill:"orange", flat:"green" };

/* データ取得 */
const rawSnap = await getDocs(collection(db,"raw_events"));
const gtSnap  = await getDocs(collection(db,"event_labels"));

const rawEvents = rawSnap.docs.map(d => ({ id:d.id, ...d.data() }));
const gtMap = {};
gtSnap.docs.forEach(d => {
  const r = d.data();
  gtMap[r.eventId] = r.groundTruth;
});

/* 整形 */
const rows = rawEvents
  .filter(ev => ev.features)
  .map(ev => ({
    auto: ev.autoLabel,
    gt: gtMap[ev.id] ?? null,
    diff: ev.features.diffMax,
    xyRatio: ev.features.xyRatio,
    xyMean: ev.features.xyRatio
  }))
  .filter(r => r.gt && r.auto);

/* ---------- 既存グラフ ---------- */

function drawScatter(){
  const data = KEYS.map(k => {
    const f = rows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.diff),
      y: f.map(r => r.xyMean),
      mode: "markers",
      type: "scattergl",
      name: LABEL[k],
      marker: { color: COLOR[k], size: 6, opacity: 0.7 }
    };
  });

  Plotly.newPlot("plot", data, {
    xaxis:{ title:"diffMax" },
    yaxis:{ title:"xyRatio" },
    margin:{t:40}
  });
}

function drawHist(){
  const data = KEYS.map(k => {
    const f = rows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.diff),
      type: "histogram",
      name: LABEL[k],
      opacity: 0.6,
      marker:{ color: COLOR[k] }
    };
  });

  Plotly.newPlot("plot", data, {
    barmode:"overlay",
    xaxis:{ title:"diffMax" },
    yaxis:{ title:"count" },
    margin:{t:40}
  });
}

function drawConfusion(){
  const matrix = {};
  KEYS.forEach(a=>{
    matrix[a]={};
    KEYS.forEach(b=>matrix[a][b]=0);
  });

  rows.forEach(r=>{ matrix[r.gt][r.auto]++; });

  const z = KEYS.map(gt => KEYS.map(auto => matrix[gt][auto]));

  Plotly.newPlot("plot", [{
    z,
    x: KEYS.map(k=>LABEL[k]),
    y: KEYS.map(k=>LABEL[k]),
    type:"heatmap",
    colorscale:"Blues"
  }],{
    xaxis:{ title:"自動判定" },
    yaxis:{ title:"正解(GT)" },
    margin:{t:40}
  });
}

function drawDecision(){
  const data = KEYS.map(k => {
    const f = rows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.xyRatio),
      y: f.map(r => r.diff),
      mode:"markers",
      type:"scattergl",
      name: LABEL[k],
      marker:{ color: COLOR[k], size:6, opacity:0.7 }
    };
  });

  Plotly.newPlot("plot", data, {
    xaxis:{ title:"xyRatio" },
    yaxis:{ title:"diffMax" },
    margin:{t:40}
  });
}

/* ---------- NEW：評価指標（表） ---------- */
function drawMetrics(){
  const total = rows.length;
  const accuracy = rows.filter(r => r.gt === r.auto).length / total;

  const table = KEYS.map(k => {
    const TP = rows.filter(r => r.gt===k && r.auto===k).length;
    const FP = rows.filter(r => r.gt!==k && r.auto===k).length;
    const FN = rows.filter(r => r.gt===k && r.auto!==k).length;

    const precision = TP / (TP + FP || 1);
    const recall = TP / (TP + FN || 1);
    const f1 = 2 * precision * recall / (precision + recall || 1);

    return {
      label: LABEL[k],
      p: precision,
      r: recall,
      f: f1
    };
  });

  Plotly.newPlot("plot", [{
    type:"table",
    header:{
      values:["クラス","正解率","適合率","再現率","F1"],
      align:"center",
      fill:{color:"#eee"}
    },
    cells:{
      values:[
        table.map(r=>r.label),
        table.map(_=>accuracy.toFixed(2)),
        table.map(r=>r.p.toFixed(2)),
        table.map(r=>r.r.toFixed(2)),
        table.map(r=>r.f.toFixed(2))
      ],
      align:"center"
    }
  }],{
    margin:{t:20}
  });
}

/* ---------- NEW：CSVダウンロード ---------- */
function downloadCsv(){
  const headers = ["eventId","autoLabel","groundTruth","diffMax","xyRatio"];
  const lines = [headers.join(",")];

  rawEvents.forEach(ev => {
    if(!ev.features) return;
    const gt = gtMap[ev.id] ?? "";
    const line = [
      ev.id,
      ev.autoLabel ?? "",
      gt,
      ev.features.diffMax ?? "",
      ev.features.xyRatio ?? ""
    ].join(",");
    lines.push(line);
  });

  const csvContent = lines.join("\n");
  const blob = new Blob([csvContent], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "event_data.csv";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/* ---------- イベントサンプル全波形データダウンロード ---------- */
function downloadAllSamples() {
  // 各イベントごとに全サンプルを展開
  let csv = "eventId,autoLabel,groundTruth,timestamp,x,y,z,diff,lat,lng\n";
  rawEvents.forEach(ev => {
    if (!ev.samples) return;
    const gt = gtMap[ev.id] ?? "";
    ev.samples.forEach(s => {
      csv += [
        ev.id, ev.autoLabel, gt, s.timestamp, s.x, s.y, s.z, s.diff, s.lat, s.lng
      ].join(",") + "\n";
    });
  });

  /* ---------- NEW：スコア化可視化 ---------- */
function drawScore(){
  // スコア化
  const scoredRows = rows.map(r => {
    const score = r.diff * 0.6 + r.zRatio * 30 + r.xyRatio * 20; // 仮の重み
    return {...r, score};
  });

  // イベントタイプごとにプロット
  const data = KEYS.map(k => {
    const f = scoredRows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.score),
      y: f.map(r => r.diff),
      mode: "markers",
      type: "scattergl",
      name: LABEL[k],
      marker: { color: COLOR[k], size: 6, opacity: 0.7 }
    };
  });

  // 閾値ライン例（score=仮の境界）
  const shapes = [
    { type: 'line', x0: 50, x1: 50, y0: 0, y1: 100, line: {color: 'black', dash:'dot'} }, // score閾値例
    { type: 'line', x0: 0, x1: 100, y0: 50, y1: 50, line: {color: 'red', dash:'dash'} }   // diffMax閾値例
  ];

  Plotly.newPlot("plot", data, {
    xaxis: { title: "Score (diff*0.6 + zRatio*30 + xyRatio*20)" },
    yaxis: { title: "diffMax" },
    margin: { t: 40 },
    shapes: shapes
  });
}


  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "all_event_samples.csv";
  a.click();
  URL.revokeObjectURL(url);
}
/* ---------- NEW：スコア化可視化 ---------- */
function drawScore(){
  // スコア化
  const scoredRows = rows.map(r => {
    const score = r.diff * 0.6 + r.zRatio * 30 + r.xyRatio * 20; // 仮の重み
    return {...r, score};
  });

  // イベントタイプごとにプロット
  const data = KEYS.map(k => {
    const f = scoredRows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.score),
      y: f.map(r => r.diff),
      mode: "markers",
      type: "scattergl",
      name: LABEL[k],
      marker: { color: COLOR[k], size: 6, opacity: 0.7 }
    };
  });

  // 閾値ライン例（score=仮の境界）
  const shapes = [
    { type: 'line', x0: 50, x1: 50, y0: 0, y1: 100, line: {color: 'black', dash:'dot'} }, // score閾値例
    { type: 'line', x0: 0, x1: 100, y0: 50, y1: 50, line: {color: 'red', dash:'dash'} }   // diffMax閾値例
  ];

  Plotly.newPlot("plot", data, {
    xaxis: { title: "Score (diff*0.6 + zRatio*30 + xyRatio*20)" },
    yaxis: { title: "diffMax" },
    margin: { t: 40 },
    shapes: shapes
  });
}

/* 初期表示 */
drawScatter();

/* ボタン */
btnScatter.onclick = drawScatter;
btnHist.onclick = drawHist;
btnConfusion.onclick = drawConfusion;
btnDecision.onclick = drawDecision;
btnMetrics.onclick = drawMetrics;
btnDownloadCsv.onclick = downloadCsv;
btnDownloadAll.onclick = downloadAllSamples;
btnScore.onclick = drawScore;
</script>
</body>
</html>
