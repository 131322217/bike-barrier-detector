<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Evaluation / 判定可視化</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.plot.ly/plotly-2.25.2.min.js"></script>

<style>
body {
  font-family: sans-serif;
  margin: 20px;
  text-align: center;
}

#plot {
  width: 95%;
  max-width: 1100px;
  height: 650px;
  margin: 20px auto;
}

button {
  margin: 4px;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
}
</style>
</head>

<body>

<h1>自動判定・GT 評価 / 判定式可視化</h1>

<div>
  <button id="btnScatter">判定式（diff × xyMean）</button>
  <button id="btnHist">diff 分布</button>
  <button id="btnConfusion">自動判定 vs GT</button>
  <button id="btnDecision">判定式決定説明</button>
  <button id="btnMetrics">評価指標（表）</button>
</div>

<div id="plot"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

/* Firebase */
const app = initializeApp({
  apiKey: "AIzaSyAb9Zt2Hw_o-wXfXby6vlBDdcWZ6xZUJpo",
  projectId: "bike-barrier-detector-1e128"
});
const db = getFirestore(app);

/* 定義 */
const KEYS = ["step","curve","hill","flat"];
const LABEL = { step:"段差", curve:"カーブ", hill:"坂", flat:"平地" };
const COLOR = { step:"red", curve:"blue", hill:"orange", flat:"green" };

/* データ取得 */
const rawSnap = await getDocs(collection(db,"raw_events"));
const gtSnap  = await getDocs(collection(db,"event_labels"));

const rawEvents = rawSnap.docs.map(d => ({ id:d.id, ...d.data() }));
const gtMap = {};
gtSnap.docs.forEach(d => {
  const r = d.data();
  gtMap[r.eventId] = r.groundTruth;
});

/* 整形 */
const rows = rawEvents
  .filter(ev => ev.features)
  .map(ev => ({
    auto: ev.autoLabel,
    gt: gtMap[ev.id] ?? null,
    diff: ev.features.diffMax,
    xyRatio: ev.features.xyRatio,
    xyMean: ev.features.xyRatio
  }))
  .filter(r => r.gt && r.auto);

/* ---------- 既存グラフ ---------- */

function drawScatter(){
  const data = KEYS.map(k => {
    const f = rows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.diff),
      y: f.map(r => r.xyMean),
      mode: "markers",
      type: "scattergl",
      name: LABEL[k],
      marker: { color: COLOR[k], size: 6, opacity: 0.7 }
    };
  });

  Plotly.newPlot("plot", data, {
    xaxis:{ title:"diffMax" },
    yaxis:{ title:"xyRatio" },
    margin:{t:40}
  });
}

function drawHist(){
  const data = KEYS.map(k => {
    const f = rows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.diff),
      type: "histogram",
      name: LABEL[k],
      opacity: 0.6,
      marker:{ color: COLOR[k] }
    };
  });

  Plotly.newPlot("plot", data, {
    barmode:"overlay",
    xaxis:{ title:"diffMax" },
    yaxis:{ title:"count" },
    margin:{t:40}
  });
}

function drawConfusion(){
  const matrix = {};
  KEYS.forEach(a=>{
    matrix[a]={};
    KEYS.forEach(b=>matrix[a][b]=0);
  });

  rows.forEach(r=>{
    matrix[r.gt][r.auto]++;
  });

  const z = KEYS.map(gt => KEYS.map(auto => matrix[gt][auto]));

  Plotly.newPlot("plot", [{
    z,
    x: KEYS.map(k=>LABEL[k]),
    y: KEYS.map(k=>LABEL[k]),
    type:"heatmap",
    colorscale:"Blues"
  }],{
    xaxis:{ title:"自動判定" },
    yaxis:{ title:"正解(GT)" },
    margin:{t:40}
  });
}

function drawDecision(){
  const data = KEYS.map(k => {
    const f = rows.filter(r => r.gt === k);
    return {
      x: f.map(r => r.xyRatio),
      y: f.map(r => r.diff),
      mode:"markers",
      type:"scattergl",
      name: LABEL[k],
      marker:{ color: COLOR[k], size:6, opacity:0.7 }
    };
  });

  Plotly.newPlot("plot", data, {
    xaxis:{ title:"xyRatio" },
    yaxis:{ title:"diffMax" },
    margin:{t:40}
  });
}

/* ---------- NEW：評価指標（表） ---------- */
function drawMetrics(){
  const total = rows.length;
  const accuracy = rows.filter(r => r.gt === r.auto).length / total;

  const table = KEYS.map(k => {
    const TP = rows.filter(r => r.gt===k && r.auto===k).length;
    const FP = rows.filter(r => r.gt!==k && r.auto===k).length;
    const FN = rows.filter(r => r.gt===k && r.auto!==k).length;

    const precision = TP / (TP + FP || 1);
    const recall = TP / (TP + FN || 1);
    const f1 = 2 * precision * recall / (precision + recall || 1);

    return {
      label: LABEL[k],
      p: precision,
      r: recall,
      f: f1
    };
  });

  Plotly.newPlot("plot", [{
    type:"table",
    header:{
      values:["クラス","正解率","適合率","再現率","F1"],
      align:"center",
      fill:{color:"#eee"}
    },
    cells:{
      values:[
        table.map(r=>r.label),
        table.map(_=>accuracy.toFixed(2)),
        table.map(r=>r.p.toFixed(2)),
        table.map(r=>r.r.toFixed(2)),
        table.map(r=>r.f.toFixed(2))
      ],
      align:"center"
    }
  }],{
    margin:{t:20}
  });
}

/* 初期表示 */
drawScatter();

/* ボタン */
btnScatter.onclick = drawScatter;
btnHist.onclick = drawHist;
btnConfusion.onclick = drawConfusion;
btnDecision.onclick = drawDecision;
btnMetrics.onclick = drawMetrics;

</script>
</body>
</html>
