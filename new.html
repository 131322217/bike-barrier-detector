<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>卒論用：集約アルゴリズム精度比較ツール</title>
<style>
  body { font-family: sans-serif; margin: 20px; line-height: 1.6; color: #333; }
  h2 { border-bottom: 2px solid #007bff; padding-bottom: 10px; }
  .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
  .card { border: 1px solid #ddd; border-radius: 8px; padding: 20px; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
  .card.best { border-color: #28a745; background: #f8fff9; }
  .metric { margin-bottom: 15px; }
  .metric-label { font-size: 0.9rem; color: #666; }
  .metric-value { font-size: 1.8rem; font-weight: bold; color: #007bff; }
  .best .metric-value { color: #28a745; }
  table { width: 100%; border-collapse: collapse; margin-top: 20px; }
  th, td { border: 1px solid #eee; padding: 12px; text-align: center; }
  th { background: #f4f4f4; }
  .btn-run { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1rem; }
  .improvement { color: #d9534f; font-weight: bold; font-size: 1.1rem; }
</style>
</head>
<body>

<h2>アルゴリズム評価：単発判定 vs 空間集約判定</h2>
<p>
  条件：新式アルゴリズム (diffMax ≧ 45, zRatio ≧ 0.55) <br>
  集約設定：半径 7m 以内のデータを集約し多数決
</p>

<button class="btn-run" id="runCalc">分析を実行</button>

<div class="dashboard" id="results" style="display:none;">
  <div class="card">
    <h3>① 単発データでの判定</h3>
    <p class="metric-label">一切の補正を行わない生の判定精度</p>
    <div class="metric">
      <div class="metric-label">F1スコア</div>
      <div id="raw_f1" class="metric-value">-</div>
    </div>
    <div class="metric">
      <div class="metric-label">正答率 (Accuracy)</div>
      <div id="raw_acc" class="metric-value">-</div>
    </div>
    <div class="metric">
      <div class="metric-label">再現率 (Recall)</div>
      <div id="raw_rec" class="metric-value">-</div>
    </div>
  </div>

  <div class="card best">
    <h3>② 空間集約（多数決）後の判定</h3>
    <p class="metric-label">近接地点をグループ化しノイズを除去した精度</p>
    <div class="metric">
      <div class="metric-label">F1スコア</div>
      <div id="agg_f1" class="metric-value">-</div>
    </div>
    <div class="metric">
      <div class="metric-label">正答率 (Accuracy)</div>
      <div id="agg_acc" class="metric-value">-</div>
    </div>
    <div class="metric">
      <div class="metric-label">再現率 (Recall)</div>
      <div id="agg_rec" class="metric-value">-</div>
    </div>
  </div>
</div>

<div id="summaryText" style="margin-top:20px; font-size:1.2rem; display:none;">
  集約処理により、F1スコアが <span id="diff_f1" class="improvement">-</span> 向上しました。
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

const app = initializeApp({
  apiKey: "AIzaSyAb9Zt2Hw_o-wXfXby6vlBDdcWZ6xZUJpo",
  projectId: "bike-barrier-detector-1e128"
});
const db = getFirestore(app);

// 距離計算
function getDist(lat1, lng1, lat2, lng2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLng/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// 指標計算
function calcMetrics(tp, fp, fn, tn) {
  const acc = (tp + tn) / (tp + fp + fn + tn || 1);
  const prec = tp / (tp + fp || 1);
  const rec = tp / (tp + fn || 1);
  const f1 = (2 * prec * rec) / (prec + rec || 1);
  return { acc, rec, f1 };
}

// 新式アルゴリズム
function isStep(f) {
  return f.diffMax >= 45 && f.zRatio >= 0.55 && !f.zConsistency && f.xyRatio < 0.45;
}

document.getElementById("runCalc").onclick = async () => {
  const [eSnap, lSnap] = await Promise.all([
    getDocs(collection(db, "raw_events")),
    getDocs(collection(db, "event_labels"))
  ]);
  
  const events = eSnap.docs.map(d => ({ id: d.id, ...d.data() }));
  const gtMap = {};
  lSnap.forEach(d => { gtMap[d.data().eventId] = d.data().groundTruth; });

  // 1. 単発判定の評価
  let rTP=0, rFP=0, rFN=0, rTN=0;
  events.forEach(ev => {
    const truth = gtMap[ev.id] === "step";
    const pred = isStep(ev.features);
    if(pred && truth) rTP++;
    else if(pred && !truth) rFP++;
    else if(!pred && truth) rFN++;
    else rTN++;
  });
  const raw = calcMetrics(rTP, rFP, rFN, rTN);

  // 2. 空間集約の評価
  const clusters = [];
  const visited = new Set();
  for (let i = 0; i < events.length; i++) {
    if (visited.has(events[i].id)) continue;
    const cluster = [events[i]];
    visited.add(events[i].id);
    for (let j = i + 1; j < events.length; j++) {
      if (!visited.has(events[j].id) && getDist(events[i].lat, events[i].lng, events[j].lat, events[j].lng) < 7) {
        cluster.push(events[j]); visited.add(events[j].id);
      }
    }
    clusters.push(cluster);
  }

  let aTP=0, aFP=0, aFN=0, aTN=0;
  clusters.forEach(cluster => {
    // クラスター全体の多数決判定
    const votes = cluster.map(ev => isStep(ev.features));
    const finalPred = votes.filter(v => v).length > votes.length / 2;
    
    // クラスター内の各データに対して、集約後の判定が当たっているかを評価
    cluster.forEach(ev => {
      const truth = gtMap[ev.id] === "step";
      if(finalPred && truth) aTP++;
      else if(finalPred && !truth) aFP++;
      else if(!finalPred && truth) aFN++;
      else aTN++;
    });
  });
  const agg = calcMetrics(aTP, aFP, aFN, aTN);

  // 結果表示
  document.getElementById("results").style.display = "grid";
  document.getElementById("summaryText").style.display = "block";
  
  document.getElementById("raw_acc").textContent = raw.acc.toFixed(3);
  document.getElementById("raw_rec").textContent = raw.rec.toFixed(3);
  document.getElementById("raw_f1").textContent = raw.f1.toFixed(3);
  
  document.getElementById("agg_acc").textContent = agg.acc.toFixed(3);
  document.getElementById("agg_rec").textContent = agg.rec.toFixed(3);
  document.getElementById("agg_f1").textContent = agg.f1.toFixed(3);

  document.getElementById("diff_f1").textContent = "+" + (agg.f1 - raw.f1).toFixed(3);
};
</script>
</body>
</html>